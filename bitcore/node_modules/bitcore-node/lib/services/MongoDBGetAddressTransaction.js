var async = require('async');
var mongo = require("mongoskin");
var index = require('../');
var log = index.log;
var bitcore = require('bitcore-lib');
var _  = bitcore.deps._;
var config = bitcore.MongodbAndUnlockConfig;


function MongoDBGetAddressTransaction(bitcoind, callback) {
	
	this.db = mongo.db(config.mongodbconfig.uri, config.mongodbconfig.options);
	this.db.bind("block");
	this.db.bind("address");
	this.db.bind("lockedTx");
	this.bitcoind = bitcoind;
	this.callback = callback;
	this.first=true;
}

MongoDBGetAddressTransaction.prototype.synchroizedBlockAdressTxToMongoDB = function() {
	var myself = this;

	async.series({
		dbHeight : function(callback) {
			myself.db.block.find({
				'id' : 1
			}).toArray(function(err, blockObj) {
				if (err) {
					log.error("dbHeight get height for mongodb err:"+err);
					return err;
				}
				if(blockObj && blockObj[0]){
					blockObj=blockObj[0];
				}
				else{
					blockObj={height:0};
				}
				console.log("init found DB height is :"+blockObj.height);
				var dbHeighRs = parseInt(blockObj.height) > 0 ? parseInt(blockObj.height) : 0;
				callback(null, dbHeighRs);
			})
		},
		blockHeight : function(callback) {
			myself.bitcoind.getInfo(function(err, blockHeight) {
				if (err) {
					log.error("getinfo err:"+err);
					return err;
				}
				console.log("init found blockchain height is :"+blockHeight.blocks);
				callback(null, blockHeight.blocks);
			})
		}
	}, function(err, heightInfo) {
		if (err) {
			log.error("synchroizedBlockAdressTxToMongoDB async.series err :"+err);
			callback(err);
		}
		var startTimestamp= new Date().getTime();
		
		console.log("开始同步数据区块链数据到mongoDB");
		var totalHandleBlock = parseInt(heightInfo.blockHeight) - parseInt(heightInfo.dbHeight) + 1;
		var oneStar = parseInt(totalHandleBlock / 100);
		oneStar = oneStar === 0 ? 1 : oneStar;
		if(myself.first){
			console.log("即将同步区块数量："+ totalHandleBlock +" one star equals to  "+oneStar);
		}
		else{
			console.log("即将同步区块数量："+ totalHandleBlock );
		}

		var handleCount = 0;
		var percent = 0;
		async.whilst(function() {
			var rs = heightInfo.blockHeight > heightInfo.dbHeight;// if true				
			return rs;
		}, function(callback) {
			heightInfo.dbHeight++;

			myself.db.block.update({
				'id' : 1
			}, {
				$set : {
					'height' : heightInfo.dbHeight
				}
			}, {
				upsert : true
			}, function(err, result) {
				if (err){
					log.error("async.whilst error update DB "+ err);
					callback(err);
				}
				else if(myself.first){
					handleCount++;
					if(Math.floor(handleCount/oneStar)>percent){
						percent++;
						process.stdout.write('*');
						if(percent===100){
							process.stdout.write('\n');
						}
					}
				}

			})
			myself.processBlockByHeight(heightInfo, callback); // do one block  height
		}, function(err, newHeight) {
			if (err) {
				log.error("whilst err:"+err);
				callback(err);
			}
			myself.db.block.update({
				'id' : 1
			}, {
				$set : {
					'height' : heightInfo.blockHeight
				}
			}, {
				upsert : true
			}, function(err, result) {
				
				if (!err && newHeight) {
					heightInfo.blockHeight = newHeight;
				}
			})
			
			log.info('');
			console.log("total synchronized time(s):"+(new Date().getTime()-startTimestamp)/1000);
			if(myself.first){
				myself.first =false;
				myself.bitcoind.emit('ready');
				log.info('');
				log.info('Bitcoin Daemon Ready');
				myself.callback();
				setInterval(myself.synchroizedBlockAdressTxToMongoDB.bind(myself), 60 * 1000);
			}
		});
	});
}

MongoDBGetAddressTransaction.prototype.processBlockByHeight = function(heightInfo, callback) {
	var myself = this;
	async.waterfall([
			myself.getTxListAndBlockMessageFromHight.bind(myself, heightInfo),
			myself.processTxList.bind(myself) 
		], function(err) {
		if (err) {
			log.error("processBlockByHeight: async.waterfall error happend:"+err);
			callback(err);
		}
		else{
			if (heightInfo.height === heightInfo.blockHeight) {
				myself.bitcoind.getinfo(function(err, info) {
					if (err) {
						callback(err);
					}
					callback(null, info.blocks);
				})
			} else {
				callback(null);
			}
		}
		
	});
}

MongoDBGetAddressTransaction.prototype.getTxListAndBlockMessageFromHight = function(heightInfo,
		callback) {
	this.bitcoind.getBlockByNumber(heightInfo.dbHeight, function(err,
			blockObject) {
		if (err) {
			callback(err);
		}
		else{
			var lockedTxData={};
			lockedTxData.currHeight=blockObject.result.height;
			lockedTxData.blockTime=blockObject.result.time;
			lockedTxData.blockHightWhenOperation=heightInfo.blockHeight;
			callback(null, blockObject.result.tx,lockedTxData);
		}
		
	})
}

MongoDBGetAddressTransaction.prototype.processTxList = function(txList,mylockedTxData,
		callback) {
	var lockedTxData=_.clone(mylockedTxData);
	var myself = this;
	var txIndex=0;
	var maxTxLength=txList.length;
	async.whilst(function() {
		var rs = maxTxLength > txIndex;// if true				
		return rs;
	},function(mycallback){
		myself.processTransaction(txList[txIndex],lockedTxData, function(err, rs) {
			txIndex++;
			if (err) {
				log.error("processTxList processTransaction error happend :"+err);
				mycallback(err);
			}
			else{
				mycallback(null);
			}
		});
	},function(err,rs){
		if (err) {
			log.error("processTxList whilst error happend :"+err);
			callback(err);
		}else{
			callback(null);
		}
	});
}


MongoDBGetAddressTransaction.prototype.processTxListOld = function(txList,
		callback) {
	var myself = this;

	async.map(txList, function(txId) {
		
		myself.processTransaction(txId, function(err, rs) {
			if (err) {
				log.error("processTxList error happend :"+err);
				callback(err);
			}
			else{
				callback(null);
			}
		});
	});
}

MongoDBGetAddressTransaction.prototype.processTransaction = function(txid,lockedTxData,
		callback) {
	var myself = this;
	
	myself.bitcoind.getRawTransactionJson(txid, function(err, transaction) {
		if (err) {
			log.error("processTransaction txid:" + txid
					+ " err:"+err);
			callback(err);
		}
		if (null == transaction) {
			console.log("processTransaction txid:" + txid
							+ " result is empty:");
		}
		lockedTxData.txid=txid;		
		lockedTxData.txTime=transaction.time;
		async.waterfall([
				myself.processEachInput.bind(myself, transaction),
				myself.processEachOutput.bind(myself, transaction,lockedTxData), ],
				function(err, result) {
					if (err) {
						log.error("processTransaction async.waterfall error happend:"+err);
						callback(err);
					} else {
						callback(null);
					}
				});
		})

}

MongoDBGetAddressTransaction.prototype.processEachInput = function(transaction,
		callback) {
	var myself = this;
	async.mapSeries(transaction.vin, function(input,mycurrCallback) {
		if (!myself.isInputValid(input)) {
			mycurrCallback(null);
		} else {
			async.waterfall([
					myself.doAddSentedValue.bind(input, myself.db,transaction.txid),
					myself.checkTxInAddressTxsList.bind(myself,input,transaction.txid),
					myself.addTxToAddressTxsList.bind(input,myself.db, transaction.txid), ],
					function(err, result) {
						if (err) {
							log.error("processEachInput async.waterfall error happend :" + err);
							callback(err);
						} else {
							mycurrCallback(null);
						}
					})
		}
	},function (err,prs){
		if(err){
			log.error("processEachInput async.map callback function error happend "+err);
			callback(err);
		}
		else{
			callback(null);
		}
		
	});
}

MongoDBGetAddressTransaction.prototype.processEachOutput = function(
		transaction,lockedTxData, callback) {
	var myself = this;
	async.mapSeries(transaction.vout, function(output,myCallback) {
		if (!myself.isOutputValid(output)) {
			myCallback(null);
		} else {
			async.waterfall([
					myself.doAddReceivedValue.bind(output, myself.db,transaction.txid,lockedTxData),
					myself.checkTxInAddressTxsList.bind(myself,output, transaction.txid),
					myself.addTxToAddressTxsList.bind(output,myself.db, transaction.txid), 
				],
					function(err, result) {
						if (err) {
							log.error("processEachOutput waterfall error happend!"+err);
							callback(err);
						} 
						else{
							myCallback(null);
						}
					});
		}
	},function(err,rs){
		if(err){
			log.error("processEachOutput async.map callback function function(err,rs) error happend:"+err)
		}
		callback(null);
	});
}


MongoDBGetAddressTransaction.prototype.isInputValid = function(input) {
	if (null === input) {
		return false;
	} else if (input.address && input.txid && input.value) {
		return true;
	}
	return false;
}

MongoDBGetAddressTransaction.prototype.isOutputValid = function(output) {
	if (null === output) {
		return false;
	} else if (output.value && output.scriptPubKey
			&& output.scriptPubKey.addresses
			&& output.scriptPubKey.addresses[0]) {
		return true;
	}
	return false;
}



MongoDBGetAddressTransaction.prototype.doAddSentedValue = function(db,txid,callback) {
	var myself = this;
	db.address.find({
		'address' : myself.address
	}).toArray(function(err, addressObj) {
		if (err) {
			log.error("getDbAddressSentedValue db.address.find err :"+err);
			callback(err);
		}
		var totalUpdateValue = 0;
		if (addressObj && addressObj[0] && addressObj[0].Sented >= 0) {
			totalUpdateValue = addressObj[0].Sented + myself.value;
		}else{
			totalUpdateValue = myself.value;
		}
		db.address.update({
			'address' : myself.address
		}, {
			$set : {
				'Sented' : totalUpdateValue
			}
		}, {
			upsert : true
		}, function(err, result) {
			if (err){
				log.error("setDbAddressSentValue db.address.update err :"+err);
				callback(err);
			}
			callback(null);
		})
	})
}

function isLocked(lockedTxData) {
	if(lockedTxData && lockedTxData.unlockHeight && lockedTxData.unlockHeight>0){
		if(lockedTxData.unlockHeight < config.Unlock.time && lockedTxData.currHeight > config.Unlock.height && lockedTxData.unlockHeight > lockedTxData.blockHightWhenOperation){
			return true;
		}
	}
	return false;
}

MongoDBGetAddressTransaction.prototype.doAddReceivedValue = function(db,txid,lockedTxData,
		callback) {
	var myself = this;
	var mylockedTxData=_.clone(lockedTxData);
	mylockedTxData.outputIndex=this.n;
	mylockedTxData.value=this.value;
	mylockedTxData.unlockHeight=this.unlockHeight;
	db.address.find({
		'address' : myself.scriptPubKey.addresses[0]
	}).toArray(function(err, addressObj) {
		if (err) {
			log.error("getDbAddressReceivedValue db.address.find err :"+err);
			callback(err);
		}
		var totalUpdateValue = 0;
		var dbLockedValue=0;
		if(isLocked(mylockedTxData)){

			if (addressObj && addressObj[0] && addressObj[0].lockedValue) {
				dbLockedValue = addressObj[0].lockedValue + myself.value;
			}else{
				dbLockedValue = myself.value;
			}
			mylockedTxData.addMany=0.05*( (( parseFloat(mylockedTxData.unlockHeight)- parseFloat(lockedTxData.currHeight))*60)/(60*60*24*30*12) )* parseFloat(mylockedTxData.value);
			mylockedTxData.address = myself.scriptPubKey.addresses[0];
			db.lockedTx.insert(mylockedTxData);
		}
		else{
			if (addressObj && addressObj[0] && addressObj[0].lockedValue) {
				dbLockedValue = addressObj[0].lockedValue;
			}
		}
		
		if (addressObj && addressObj[0] && addressObj[0].Received >= 0) {
			totalUpdateValue = addressObj[0].Received + myself.value;
			
		}else{
			totalUpdateValue = myself.value;
			
		}
		db.address.update({
			'address' : myself.scriptPubKey.addresses[0]
		}, {
			$set : {
				'Received' : totalUpdateValue,
				'lockedValue':dbLockedValue
			}
		}, {
			upsert : true
		}, function(err, result) {
			if (err){
				log.error("setDbAddressReceivedValue db.address.update err :"+err);
				callback(err);
			}
			callback(null);
		})
		
	})

}

MongoDBGetAddressTransaction.prototype.isInArray=function(obj,arr){
	
	for(var i=0;i<arr.length;i++){
		if(obj===arr[i]){
			return true;
		}
	}
	return false;
}

MongoDBGetAddressTransaction.prototype.checkTxInAddressTxsList = function(v,txid,
		callback) {
	var myself = this;
	
	myself.db.address.find(
			{'address' : v.address ? v.address: v.scriptPubKey.addresses[0]}
		).toArray(function(err, addr) {

		var txList = [];
		if (addr && addr[0] && addr[0].txs) {
			
			if(!myself.isInArray(txid,addr[0].txs)){
				addr[0].txs.push(txid);
			}
			callback(null,addr[0].txs);
		} else {
			
			txList.push(txid);
			callback(null,txList);
		}
	})

}

MongoDBGetAddressTransaction.prototype.addTxToAddressTxsList = function(db,txid,
		txList, callback) {
	var myself = this;

	db.address.update({
		'address' : myself.address ? myself.address
				: myself.scriptPubKey.addresses[0]
	}, {
		$set : {
			'txs' : txList
		}
	}, function(err, result) {
		if (err){
			log.error("update address txlist error : "+err);
			callback(err);
		}
		callback(null);
	})
}

module.exports = MongoDBGetAddressTransaction;